//strcpy
// strcat
// strcmp
// strncpy
//strncat
//stncmp
//操作的对象是：字符串，\0
//
// 
//整形数组
//浮点型数组
//结构体数组
//
//
//void*memcpy(void*destination,const void*source,size_t num);
//              目的地              源头           字节数

#include<stdio.h>
#include<string.h>
#include<assert.h>
//struct S
//{
//	char name[20];
//	int age;
//};
////void *my_memcpy(void* dest,const void*src,size_t num)
////{
////	void* ret = dest;
////	assert(dest!= NULL);
////	assert(src != NULL);
////	while (num--)
////	{
////		*(char*)dest = *(char*)src;
////		++(char*)dest;
////		++(char*)src;
////	}
////	return ret;
////}
////memcpy拷贝一旦和自己有关联会出错  不能拷贝自己的自生子链
////memcpy 只要处理不重复的内存拷贝就可以
//// memmove处理内存重叠情况
////void*memmove(void*dest,const void*source,size_t num);
////              目的地              源头           字节数
//void*my_memmove(void* dest, const void* src, size_t count)
//{
//	/* dest落在src左边  从前往后拷贝
//	 dest落在src中间或者右边 从后往前考*/
//	//char* ret = dest;
//	assert(dest != NULL);
//	assert(src != NULL);
//	void* ret = dest;
//	//int i = 0;
//	//while (count--)
//	//{
//	//	*(char*)dest = *(char*)src;
//	//	++(char*)dest;//强制类型转换要比++晚
//	//	++(char*)src;
//	//}
//	//return ret;
//	if (dest<src || dest>(char*)src + count)
//	{
//		//前->后
//	}
//	else
//	{
//
//	}
//	//if (dest < src)
//	//{
//	//	
//	//	//前->后
//	//	while (count--)
//	//	{
//	//		*(char*)dest = *(char*)src;
//	//		++(char*)dest;
//	//		++(char*)src;
//	//	}
//	//}
//	//else
//	//{
//	//	//后->前
//	//	while (count--)
//	//	{
//	//		*((char*)dest + count) = *((char*)src + count);
//	//	}
//	//}
//	//return ret; 
// }
//int main()
//{
//	int arr1[] = { 1,2,3,4,5,6,7,8,9,10};
//	int arr2[5] = { 0 };
//	//struct S arr3[] = { {"张三",20},{"李四",30} };
//	//struct S arr4[3] = { 0 };
//	//memcpy(arr4, arr2, sizeof(arr3));
//    my_memmove(arr1 + 2, arr1, 20);
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", arr1[i]);
//	}
//	//my_memcpy不能胜任重叠拷贝
//	// C语言标准说：memcpy函数可以拷贝不重叠的就可以了
//	// 当下发现：vs2013环境下的memcpy可以处理重叠拷贝
//	//char*dest,const char*src
//	//strcpy(arr2, arr1);
//	//memmove可以处理重复和不重复
//
// 	return 0;
//}
//memcmp
//memmove
//memcmp
//memset
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 1,2,5,4,3 };
	int ret = memcmp(arr1, arr2, 8);
	printf("%d\n", ret);
	
	return 0;
}
int main()
{
	/*char arr[10] = "";
	memset(arr, '#', 10);*/
	      // 这个数字10是字节数
	
	
	return 0;
}




















